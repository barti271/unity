// Define the namespace
// Based on https://vaadin.com/docs/v7/framework/gwt/gwt-javascript.html
var unityfido = unityfido || {};

// Fido component instance
var fidocomponent;

/**
 * FidoComponent JavaScript counterpart.
 */
window.pl_edu_icm_unity_webui_fido_FidoComponent =
	function() {
		// Create the component
		fidocomponent =
			new unityfido.FidoComponent(this.getElement());

		// Handle changes from the server-side
		this.onStateChange = function() {
			const state = this.getState();
			fidocomponent.regButton.setup(state.regEnabled, state.regCaption);
			fidocomponent.authButton.setup(state.loginEnabled, state.loginCaption);
			//fidocomponent.setValue(this.getState().value);
		};

		// Pass user interaction to the server-side
		var self = this;

		// Triggers BE to start FIDO registration process on authenticator for given user.
		fidocomponent.invokeRegistration = function() {
			self.invokeRegistration(fidocomponent.getUsername());
		};

		// Send promise returned by FIDO authenticator to BE for validation and credential storage.
		fidocomponent.finalizeRegistration = function(key, value) {
			self.finalizeRegistration(key, value);
		};

		// Triggers BE to start FIDO authentication process on authenticator for given user.
		fidocomponent.invokeAuthentication = function() {
			self.invokeAuthentication(fidocomponent.getUsername());
		};

		// Send promise returned by FIDO authenticator to BE for validation.
		fidocomponent.finalizeAuthentication = function(key, value) {
			self.finalizeAuthentication(key, value);
		};

		// Show error window.
		fidocomponent.showError = function(title, msg) {
			self.showError(title, msg);
		};
	};

/**
 * UI controls for FidoComponent interactions.
 */
unityfido.FidoComponent = function (element) {
	element.innerHTML =
		"<div class='textinput'>" +
		"	<input class='v-textfield v-widget' type='text' name='value' style='margin-right: 10px'/>" +
		"		<div role='button' class='v-button v-widget' style='margin-right: 10px'>" +
		"			<span class='v-button-wrap'><span class='v-button-caption' name='registration-caption'>Register</span></span>" +
		"		</div>" +
		"		<div role='button' class='v-button v-widget' style='margin-right: 10px'>" +
		"			<span class='v-button-wrap'><span class='v-button-caption'>Login</span></span>" +
		"		</div>" +
		"</div>";

	// Function to fetch username value form input control.
	var self = this; // Can't use this inside the function
	self.usernameField = element.getElementsByTagName("input")[0];
	self.getUsername = function () {
		return self.usernameField.value;
	};

	// Setup registration button
	self.regButton = element.getElementsByTagName("div")[1];
	self.regButton.caption = element.getElementsByTagName("span")[1];
	self.regButton.onclick = function () {
		self.invokeRegistration();
	};
	this.regButton.setup = function(enabled, caption) {
		this.style.display = enabled === true ? 'run-in' : 'none';
		this.caption.textContent = caption;
	}

	// Setup authentication button
	self.authButton = element.getElementsByTagName("div")[2];
	self.authButton.caption = element.getElementsByTagName("span")[3];
	self.authButton.onclick = function () {
		self.invokeAuthentication();
	};
	self.authButton.setup = function(enabled, caption) {
		self.style.display = enabled === true ? 'run-in' : 'none';
		self.caption.textContent = caption;
	}
};

/**
 * Triggers FIDO authenticator registration process on client side. Called from BE.
 * @param options Registration options.
 */
function createCredentials(key, options) {
	const convertedOptions = convertOptions(JSON.parse(options));
	navigator.credentials.create({
		publicKey: convertedOptions
	}).then(promise => {
		const convertedPromise = convertPromise(promise);
		fidocomponent.finalizeRegistration(key, JSON.stringify(convertedPromise));
	}).catch(err => {
		fidocomponent.showError("Fido registration", err.message);
	});
};

/**
 * Triggers FIDO authenticator authentication process on client side. Called from BE.
 * @param options Registration options.
 */
function getCredentials(key, options) {
		const convertedOptions = convertOptions(JSON.parse(options));
		navigator.credentials.get({
			publicKey: convertedOptions.publicKeyCredentialRequestOptions
		}).then(promise => {
			const convertedPromise = convertPromise(promise);
			fidocomponent.finalizeAuthentication(key, JSON.stringify(convertedPromise));
		}).catch(err => {
			fidocomponent.showError("Fido authentication", err.message);
		});
};

/**
 * Coverts String representation of registration/authentication options received from BE to Arrays acceptable by FIDO authenticators.
 * @param options Registration or authentication options generated by BE
 * @returns {*} Converted options
 */
function convertOptions(options) {

	if (options.publicKeyCredentialRequestOptions) {
		const challenge = options.publicKeyCredentialRequestOptions.challenge.replace(/-/g, "+").replace(/_/g, "/");
		options.publicKeyCredentialRequestOptions.challenge = Uint8Array.from(atob(challenge), c => c.charCodeAt(0));

		const allowCredentials = options.publicKeyCredentialRequestOptions.allowCredentials && options.publicKeyCredentialRequestOptions.allowCredentials.map(credential => {
			const credId = credential.id.replace(/-/g, "+").replace(/_/g, "/");
			credential.id = Uint8Array.from(atob(credId), c => c.charCodeAt(0));
			return credential;
		});
	} else {

		const challenge = options.challenge.replace(/-/g, "+").replace(/_/g, "/");
		options.challenge = Uint8Array.from(atob(challenge), c => c.charCodeAt(0));

		const userid = options.user.id.replace(/-/g, "+").replace(/_/g, "/");
		options.user.id = Uint8Array.from(atob(userid), c => c.charCodeAt(0));

		const excludeCredentials = options.excludeCredentials && options.excludeCredentials.map(credential => {
			const credId = credential.id.replace(/-/g, "+").replace(/_/g, "/");
			credential.id = Uint8Array.from(atob(credId), c => c.charCodeAt(0));
			return credential;
		});
		options.excludeCredentials = excludeCredentials;
	}

	return options;
}

/**
 * Covert response fields received from FIDO authenticator to Base64Url encoded String acceptable by BE
 * @param promise Promise returned by FIDO authenticator
 * @returns {{response: {clientDataJSON: *, attestationObject: *}, id: *, type: *, clientExtensionResults: *}} Converted promise.
 */
function convertPromise(promise) {
	let clientExtensionResults = {};

	try {
		clientExtensionResults = promise.getClientExtensionResults();
	} catch (e) {
		console.error('getClientExtensionResults failed', e);
	}

	if (promise.response.attestationObject) {
		return {
			type: promise.type,
			id: promise.id,
			response: {
				attestationObject: coerceToBase64Url(promise.response.attestationObject),
				clientDataJSON: coerceToBase64Url(promise.response.clientDataJSON),
			},
			clientExtensionResults
		};
	}
	if (promise.response.authenticatorData) {
		return {
			type: promise.type,
			id: promise.id,
			response: {
				authenticatorData: coerceToBase64Url(promise.response.authenticatorData),
				clientDataJSON: coerceToBase64Url(promise.response.clientDataJSON),
				signature: coerceToBase64Url(promise.response.signature),
				userHandle: promise.response.userHandle && coerceToBase64Url(promise.response.userHandle),
			},
			clientExtensionResults
		};
	}
}

/**
 * Converts arays to Base64Url encoded String.
 * @param thing Array or ArrayBuffer to be converted.
 * @returns {string} String value
 */
function coerceToBase64Url(thing) {
	// Array or ArrayBuffer to Uint8Array
	if (Array.isArray(thing)) {
		thing = Uint8Array.from(thing);
	}

	if (thing instanceof ArrayBuffer) {
		thing = new Uint8Array(thing);
	}

	// Uint8Array to base64
	if (thing instanceof Uint8Array) {
		var str = "";
		var len = thing.byteLength;

		for (var i = 0; i < len; i++) {
			str += String.fromCharCode(thing[i]);
		}
		thing = window.btoa(str);
	}

	if (typeof thing !== "string") {
		throw new Error("could not coerce to string");
	}

	// base64 to base64url
	// NOTE: "=" at the end of challenge is optional, strip it off here
	thing = thing.replace(/\+/g, "-").replace(/\//g, "_").replace(/=*$/g, "");

	return thing;
}